/***************************
   * This is the implementation of the multi threaded server that uses Unix domain stream sockets,
   to communicate with the client process. * 
   * This server receives the "N" integers received from the client * 
   * It then verifies whether the integers received are the first N primes of the fibonacci sequence. * 
   * If thats the case, the server sends a response "Sequence Ok" else it sends a response "Check Failed" *
   
   
****************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

/*For UNIX domain sockets*/
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>

/*For multi threading. */
#include <pthread.h>

/*The file to which we link our unix socket to. */
#define SOCKET_PATH "fibonacci_server"

/*Global mutex object to protect critical sections of code.*/
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

/*struct that represents an incomming connection that gets accepted. */
typedef struct CONNECTION
{
	int client_sock;				/*The client's socket descriptor */
	struct sockaddr_un client_addr; /*The client's UNIX domain address */
} CONNECTION;

/*The following is a helper function that checks if a given number is prime... Returns 1 if number is prime 0 otherwise. */
int is_prime(int x)
{
	if (x < 2)
	{
		/* 0 and 1 are not prime */
		return 0;
	}

	if (x == 2)
	{
		/*Two is definitely prime. */
		return 1;
	}

	/*We brute force search whether number is prime. */
	for (int i = 2; i < (x / 2); i++)
	{
		if ((x % i) == 0)
		{
			/*If a factor is found then the number "x" is not prime. */
			return 0;
		}
	}

	return 1; /*Number is prime. */
}

/*The following function generates the first "n" fibonacci primes and places it into array "arr" ! */
void first_n_prime_fibonacci(int *arr, int n)
{
	int c = 0; /*Count of primes reached so far. */

	/*The first two fibonacci numbers. */
	int a = 0;
	int b = 1;

	while (c < n)
	{
		/*Third fibonacci number generated by adding the last two. */
		int new_term = a + b;

		if (is_prime(new_term) == 1)
		{
			/*If the fibonacci number generated this time is a prime we place it in the array and increment the index.  */
			arr[c] = new_term;
			c++;
		}

		/*We update the last two fibonacci numbers for the next iteration.  */
		a = b;
		b = new_term;
	}
	
	for (c=0; c<n; c++)
	{
		printf("%d\n", arr[c]);
	}
}

/*Thread function that handles the connection. */
void *handle_connection(void *data)
{
	/*We cast the pointer to the correct struct pointer. */
	CONNECTION *conn = (CONNECTION *)data;

	pthread_mutex_lock(&mutex);
	printf("\n[*]Connection received from UNIX stream socket client! \n");
	pthread_mutex_unlock(&mutex);

	/*Client socket*/
	int cl_sock = conn->client_sock;

	/*Now we begin service to the client. */
	/*The server initially expects the client to at first send the number of integers in the sequence. */

	/*If that number is zero, then that means service needs to be stopped.. */

	while (1)
	{
		int num = 0;

		/*We read the number of integers in the sequence. */
		if (read(cl_sock, &num, sizeof(int)) < 0)
		{
			perror("read() ");
			break;
		}

		if (num == 0)
		{
			/*Client wants to end connection ! */
			
			break;
		}
		
		pthread_mutex_lock(&mutex);
		printf("\n[*]User wants to send %d integers... \n", num); 
		pthread_mutex_unlock(&mutex);

		/*We allocate memory for storing the sequence that will be sent by the client. */
		int *seq = (int *)malloc(sizeof(int) * num);

		/*Second array to store the correct sequence. */
		int *correct_seq = (int *)malloc(sizeof(int) * num);

		/*We tell the client to start sending the sequence of integers that need to be checked. */

		if (write(cl_sock, "SEND", strlen("SEND") + 1) < 0)
		{
			perror("write() ");
			break;
		}
		
		/*We finally read() the sequence of integers from the client. */
		if(read(cl_sock, seq, sizeof(int) * num) < 0)
		{
			perror("read() "); 
			break; 
		}
		
		/*Now we generate the correct sequence of primes that are the first "num" numbers of the fibonacci sequence. */
		first_n_prime_fibonacci(correct_seq, num); 
		
		/*Now we compare whether our received sequence is same as the generated sequence. If its the same, then we send response to the client stating that the sequence is OK 
		* Otherwise, we send response to the client stating that the checking failed.  ""
		*/
		
		if(memcmp(seq, correct_seq, sizeof(int) * num)==0) 
		{
			/*The sequences are same! */
			if(write(cl_sock, "Sequence Ok", strlen("Sequence Ok")+1) < 0)
			{
				perror("write() "); 
				break; 
			}
		}else{
			/*The sequences are different so verification failed !*/
			if(write(cl_sock, "Check Failed", strlen("Check Failed")+1) < 0)
			{
				perror("write() "); 
				break; 
			}
		}
		

		free(seq);
		free(correct_seq);
	}
	
	pthread_mutex_lock(&mutex);
	printf("\n[*]Connection handling thread ended... \n");
	pthread_mutex_unlock(&mutex);

	close(cl_sock);
	free(conn);
	return NULL;
}

/*Main entry point of our application*/
int main(int argc, char *argv[])
{
	

	printf("###### PRIME FIBONACCI SEQUENCE VERIFICATION SERVER #####\n");

	/*We first create the UNIX stream socket file descriptor for the server*/

	int server_sock = socket(AF_UNIX, SOCK_STREAM, 0);

	if (server_sock == -1)
	{
		/*An error has occured. */
		perror("ERROR: socket() ");
		return 0;
	}

	/*We unlink the SOCKET_PATH, if such a path is already set up. */
	unlink(SOCKET_PATH);

	/*Now we intialize the UNIX socjet address structure. */
	struct sockaddr_un serv_addr;

	/*We reset all bytes to zero. */
	memset(&serv_addr, 0x00, sizeof(serv_addr));

	/*We specify the family of socket which is basically AF_UNIX*/
	serv_addr.sun_family = AF_UNIX;

	/*We copy the path name. */
	strncpy(serv_addr.sun_path, SOCKET_PATH, strlen(SOCKET_PATH));

	/*Now we bind() our server socket to the UNIX server address. */

	if (bind(server_sock, (struct sockaddr *)&serv_addr, sizeof(struct sockaddr_un)) == -1)
	{
		/*An error occured with bind() */
		perror("ERROR: bind()");
		return 1;
	}

	/*We set up the socket to listen for incomming connections... */

	if (listen(server_sock, 5) == -1)
	{
		/*An error occured with listen() */
		perror("ERROR: listen()");
		return 2;
	}

	/*Now the server enters its infinite service loop where it accepts incomming connections and spawns individial threads to serve them. */

	printf("\n#------- SERVER IS RUNNING -------#\n");

	/*We dynamically allocate an array of pthread_t to store thread IDs. This array grows in size when more threads are created.  */

	int num = 10;
	pthread_t *tids = (pthread_t *)malloc(num * sizeof(pthread_t));

	int idx = 0; // Index into the above array...

	while (1)
	{
		/*We dynamically allocate the CONNECTION structure that will store the client's socket descriptor and its address that will be captured from accept() */

		CONNECTION *conn = (CONNECTION *)malloc(sizeof(CONNECTION));

		/*Wait for a connection to be accepted. */
		socklen_t len = sizeof(struct sockaddr_un);
		conn->client_sock = accept(server_sock, (struct sockaddr *)&conn->client_addr, &len);

		/*We need to check if accept succeeded. */
		if (conn->client_sock == -1)
		{
			/*An error occured */
			perror("ERROR: accept()");
			break;
		}

		/*We need to allocate more thread IDs if required. */
		if (idx == num)
		{
			tids = (pthread_t *)realloc(tids, (num + 1) * sizeof(pthread_t));
			num++;
		}

		/*Once accept returns we can start the new thread that will handle the connection.*/

		if (pthread_create(&tids[idx], NULL, handle_connection, (void *)conn) == -1)
		{
			/*If we fail to create the thread we skip the handling of this connection. */
			perror("[!]Skipping connection");
			continue;
		}

		/*Update the index*/
		idx++;
	}

	printf("\n\n#------ SERVER IS SHUTTING DOWN ------#\n");

	/*We close the server socket descriptor. */
	close(server_sock);

	/*We unlink the path. */
	unlink(SOCKET_PATH);

	/*We join all the threads we have created so far. */
	for (int i = 0; i < num; i++)
		pthread_join(tids[i], NULL);

	/*Free the dynamically allocated array of thread IDs. */
	free(tids);

	return 0;
}
